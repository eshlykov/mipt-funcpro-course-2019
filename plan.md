# Примерный план семинаров

## Семинар 1

- [x] Организационная часть
- [x] Базовые типы в F#
- [x] Объявление значений
- [x] Вывод на экран
- [x] Основные операторы
- [x] Знак остатка от деления
- [x] Бесконечности и `nan`
- [x] Объявления собственных операторов
- [x] Объявление функций
- [x] Функциональные типы
- [x] Как записывать вызов функции
- [x] Каррирование
- [x] Типизация аргументов
- [x] Преобразования типов
- [x] Функции с вложенными объявлениями
- [x] Строки
- [x] Конкатенация
- [x] Строка с `@`
- [x] Взятие подстроки
- [x] Кортежи
- [x] Получение элементов
- [x] Распаковка кортежа
- [x] Опциональный тип
- [x] Проверка и доступ к элементу
- [x] Объявление типов
- [x] Условный оператор
- [x] Условный оператор типа `unit`
- [x] Тип-сокращение
- [x] Размеченное объединение
- [x] Объединение из одной ветви
- [x] Реализация собственного опционального типа
- [x] Сопоставление с образцом
- [x] Сопоставление при условии
- [x] Логические операторы в паттернах

## Семинар 2

- [x] Вопрос: объявление унарных операторов
- [x] Вопрос: перегрузка функций
- [x] Вопрос: как устроены исключения
- [x] Перечисления
- [x] Рекурсия
- [x] Реализация цикла
- [x] Цикл `for`
- [x] Реализация списков
- [x] Списки
- [x] Конструктор списка
- [x] Пкречисление через точку с запятой и построчно
- [x] Задание диапазоном
- [x] Генератор списка
- [x] Конкатенация
- [x] Лямбда-выражения
- [x] Отличия `fun` и `function`
- [x] Сопоставление с образцом для `function`
- [x] Библиотека для работы со списками: `head`, `tail`, `length`, `item` и др.
- [x] Функции высших порядков: `map`, `filter`, `fold`
- [x] Отличия `fold` и `reduce`
- [x] Другие ФВП
- [x] Конвейер: `|>`, `<|`
- [x] Игнорирование значений
- [x] Композиция: `>>`, `<<`
- [x] Асимптотика функций работы со списками
- [x] Хвостовая рекурсия
- [x] Продолжения
- [x] Задачки на семинаре: `forall`, `partition`

## Семинар 3

- [x] Перечисления
- [x] Дженерики
- [x] Деревья общего вида
- [x] Обход в глубину
- [x] Печать дерева
- [x] Отображение деревьев
- [x] Двоичные деревья
- [x] Префиксный, инфиксный, постфиксный обходы
- [x] Бинарные деревья поиска
- [x] Подсчет количества элементов с помошью продолжений
- [x] Абстрактные синтаксические деревья
- [x] Вычисление выражений
- [x] Переменные
- [x] Массивы
- [x] Перечисление элементов, диапазон, инкремент, генератор
- [x] `Array.zeroCreate`, `Array.init`
- [x] Доступ по индексу
- [x] Слайсы
- [x] Мутабельность
- [x] Итерирование по массиву
- [x] Библиотека работы с массивами
- [x] Многомерные массивы
- [x] Параллельная обработка массива
- [x] Множества и словари
- [x] Иммутабельность, методы, операции, стандартная библиотека

## Семинар 4

- [x] Замыкания
- [x] Статическое связывание
- [x] Динамическое связывание
- [x] Имитация динамического связывания
- [x] Генератор с помощью переменных 
- [x] Генератор с помощью указателей
- [x] Функции для работы с гененаторами
- [x] Ленивые последовательности
- [x] Перечисление элементов
- [x] Элементы через `yield`
- [x] Генератор последовательностей
- [x] Диапазон, инкремент
- [x] Рекурсивные последовательности: `yield!`
- [x] Бесконечные последовательнсоти
- [x] Функции для работы с последовательностями
- [x] Энергичные вычисления
- [x] Ленивые вычисления
- [x] Тип `Lazy`
- [x] Потоки
- [x] Проблема разделения 
- [x] Мемоизация
- [x] Мемоизация в `Lazy`
- [x] Вычисление чисел Фибоначчи с мемоизацией
- [x] Монады
- [x] Встроенные монады: `seq`
- [x] Метод `yield!`
- [x] Метод `yield!`
- [x] Встроенные монады: `async`
- [x] Метод `return`
- [x] Метод `return!`
- [x] Метод `let!`
- [x] Метод `do!`
- [x] `Async.RunSynchronously`
- [x] `Async.Start`

---

- [ ] Записи
- [ ] Объявление экземпляра через точку с запятой и построчно
- [ ] Копирование и обновление
- [ ] Обращение к полям
- [ ] Методы записей
- [ ] Классы
- [ ] Внутренние члены класса
- [ ] Методы класса
- [ ] Обобщенные классы
- [ ] Вывод параметра
- [ ] Активные шаблоны
- [ ] Единицы измерения
- [ ] Тип `Result<'T,'Failure>`
- [ ] Хеш-таблицы