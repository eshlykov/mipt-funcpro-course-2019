// Рассмотрим следующий пример
let x = 0
let add y = x + y
// Функция add использует ссылку на константы x, описанную вне определения самой функции. Поэтому определение функции
// add содержит в себе также ссылку на переменную x. Такая функция называется замыканием

// Важно, что значение константы берется на момент создания функции
printfn "%A" (add 1)  // Выведет 1
// let x = 1  // Нужно запускать в F# Interactive, иначе будет переопределение имени
printfn "%A" (add 1)  // Выведет 1, а  не 2

// Это называется статическим связыванием. В некоторых языках (Lisp?), связывание динамическое, то есть
// значение переменной берется на момент вызова замыкания

// В F# можно сделать динамическое связывание, используя переменные

let mutable y = 0
let sub x = x - y
y <- 1
printfn "%A" (sub 1)

// C помошью динамического связывания можно, например, делать генераторы
let mutableCounter start =
    let mutable next = start
    fun () ->
        next <- next + 1
        next

let counter2 = mutableCounter 2
printfn "%A" (counter2 ())
printfn "%A" (counter2 ())
printfn "%A" (counter2 ())

// Другой механизм - указатели. Для создания указателя используется слово ref, а для разыменования - !
// Для изменения значения - знак :=
let refCounter start =
    let next = ref start  // Тип int ref
    fun () ->
        next := !next + 1
        !next

let counter3 = refCounter 3
printfn "%A" (counter3 ())
printfn "%A" (counter3 ())
printfn "%A" (counter3 ())

// Генераторы позволяют больше расходовать меньше памяти, чем при работе со списками
// Рассмотрим, например, первые 10 чисел Фибоначчи, кратные трем
// В случае со списками нам пришлось бы создавать огромные список и фильтровать его
// (последнее значение - 102334155, это 41-й элемент)

// Реализуем это на генераторах

// Для начала обобщим алгоритм
let makeGenerator start apply get =
    let next = ref start
    fun () ->
        next := apply !next
        get !next

let fibGenerator = makeGenerator (0, 1) (fun (current, next) -> (next, current + next)) fst
printfn "%A" (fibGenerator ())
printfn "%A" (fibGenerator ())
printfn "%A" (fibGenerator ())

// Теперь мы умеем получать последовательность чисел Фибоначчи
// Напишем функцию, которая будет пропускать элементы, пока они не удовлетворяют условию
let rec skip cond gen =
    let x = gen ()
    if cond x then x
    else skip cond gen

// Фильтрация - это прсото генератор, который возвращает значения после скипов
let filter cond gen =
    fun () -> skip cond gen

// Напишем теперь функцию take, которая берет первые элементы генератора
let take count gen =
    let rec take' count acc =
        if count = 0 then acc
        else (gen ()) :: (take' (count - 1) acc)
    take' count []

// Итого
let fibDivisibleBy3 = take 10 (filter (fun x -> x % 3 = 0) fibGenerator)
printfn "%A" fibDivisibleBy3

// Заметим, что здесь все вычисления происходили лениво. То есть элемент вычислялся только тогда, когда нам сказали
// добавить новый элемент. Если бы мы работали со списком, то нам бы пришлось сгенерировать большой список с запасом,
// а потом его отфильтровать и взять первые 10 элементов.

// В F# есть ленивые последовательнсти, или просто последовательности. Это, как и список, упорядоченный набор элементов
// одного типа. В отличие от списков и массивов, последовательности вычисляются по требованию (как у нас было с
// генератором)

// Функция для работы с последовательностями лежат в модуле Seq
let empty = Seq.empty
let ten = seq { 1 .. 10 }
let oddTen = seq { 1 .. 2 .. 20 }  // 1 3 5 ... 19
let elems = seq [ 1; 2; 3 ]
let yields = seq { yield 1; yield 2; yield 3 }
let forYield = seq { for i in 1 .. 10 do yield i * i }
let forArrow = seq { for i in 1 .. 10 -> i * i }  // Сокращенная запись
let evenNumbers = Seq.init 1001 (fun n -> n * 2)

// Можно сгенерировать не один элемент, а последовательность элементов, нужно использовать yield!. В этом случае
// сгенерированная последовательность присоединиться к списку

let rand = System.Random()

// Только теперь это уже фукнция из дабла в последовательность, а не просто последовательность
let rec randomWalk x = seq {
    yield x
    yield! randomWalk (x + rand.NextDouble() - 0.5)
}
// Первый элемент - x, а после него его идеть последовательность randomWalk (x + rnd.NextDouble() - 0.5) -
// это рекурсивный вызов

randomWalk 0.0
|> Seq.truncate 10
|> Seq.toList
|> (printfn "%A")

// Заметим, что эта последовательность бесконечная. Но так как элементы вычисляются по требованию, это ок

// Фукнции для работы с последовательностями, в общем-то, примерно такие же, как и для работы со списками,
// только ленивые. Здесь ничего удивительного

// В функциональном программирование основная операция - применение аргументов к функции, или аппликация. Аргумент при
// этом может быть также функцией с примененными к нему аргументами. Допустим, у нас есть f(g(x)). Тогда есть два пути:
// 1. Энергичные вычисления: сначала вычисляем значение, а потом подставляем его в функцию
// 2. Ленивые вычисления: подставляем все выражение в функцию, а вычисляем при возвращении из функции значения

// Есть еще вариант вычислять значение каждый раз и не сохранять его, так работают function-like-макросы в C/C++

// В F# по умолчанию все вычисления происходят лениво, то есть на момент входа в функцию все аргументы уже посчитаны.
// Это сделано для удобства взаимодействия с .NET. В некоторых языках, например, Haskell, вычисления происходят лениво

// В случае ленивых вычислений достаточно сложно предугадать, в каком порядке будут произведены вычисления. Однако
// если мы пишем код (без побочных эффектов), это не сильно важно

// В F# есть поддержка ленивых вычислений. Например, ленивые последовательности - частный случай ленивых вычислений
// С другой стороны, можно явно отложить вычисления и вызвать его с помощью lazy и Force()
let lazyAction = lazy(printfn "%A" 1)  // Тип Lazy<unit>. На экран ничего не выведено
lazyAction.Force() |> ignore

// С помощью ленивых вычислений можно реализовать свой тип
type 'a Sequence =
    | Empty
    | Ctor of 'a * 'a Stream
and 'a Stream = Lazy<'a Sequence>
// Здесь нужно при объявлении второго типа написать and, чтобы сработала взаимная рекурсия в опредлеении

let stream1 = lazy(Ctor (1, lazy(Ctor (2, lazy(Empty)))))

// Функция для преобразования списка в поток
let rec toStream = function
    | [] -> lazy(Empty)
    | x :: xs -> lazy(Ctor (x, toStream xs))

let stream2 = toStream [ 1; 2; 3 ]

// Перепишем наши функции для работы с генераторами на потоки
let rec skipStream cond (stream : 'a Stream) =
    match stream.Force() with
    | Empty -> None
    | Ctor (x, _) when cond x -> Some x
    | Ctor (_, xs) -> skipStream cond xs

// В случае ленивых вычислений возникает так называемая проблема разделения. Самый простой пример - возведение
// в квадрат. В энергичном случае аргумент будет сначала вычислен, а затем перемножен. А в ленивом случае вычисление,
// казалось бы, произойдет дважды. (Разделение - так как один и тот же аргумент разделяет на несколько копий.)
// Так ведут себя макросы в C/C++, поэтому там обычно сохраняют аргумент в переменую, если он используется чаще
// одного раза

// Тоже самое с нелинейной рекурсией, например, числами Фибоначчи. Для вычисления n-го (от 0, fib[0] = fib[n] = 1)
// числа вычисление k-го (k от 1 до n) происходит fib[n - k] раз (но это не точно).

// В F# и других языках программирования, чтобы ленивый аргумент вычислялся только один раз, используется мемоизация
// В этом можно убедиться:
let lazyPrint = lazy(printfn "%A" 1)
lazyPrint.Force() |> ignore
lazyPrint.Force() |> ignore  // Нет вывода на экран

// Реализация чисел Фибоначчки с мемоизация
let mutable counter = 0  // Для проверки числа вызовов
let makeFib () =
    let mutable cache = [1; 0]
    let rec fib' n =
        if n >= cache.Length then
            counter <- counter + 1
            cache <- ((fib' (n - 1)) + (fib' (n - 2))) :: cache
        cache.[cache.Length - 1 - n]
    fib'

let fib = makeFib ()

printfn "%A" (fib 0)
printfn "%A" (fib 1)
printfn "%A" (fib 2)
printfn "%A" (fib 3)
printfn "%A" (fib 4)
printfn "%A" (fib 5)

printfn "%A" (fib 9)
printfn "%A" counter

printfn "%A" (fib 14)
printfn "%A" counter

printfn "%A" (fib 9)
printfn "%A" counter

// Монады (в F# - Computation Expressions) - это вычислительный design pattern. Зачем они нужны?
// Во-первых, они используются в чистом функциональном программировании для задания явной последовательности
// вычислений. Это важно для ленивых языков, так как там порядок вычислений непредсказуем. Монады позволяют эти
// вычисления упорядочить.
// Во-вторых, в чистом функциональном программировании отсутствуют побочные эффекты. Но в реальности, конечно,
// побочные эффекты есть. Тот же ввод-вывод, например, изменяет состояние консоли. Монады позволяют реализовать
// императивный подход внутри функционального. (Например, в Haskell ввод-вывод сделан через монады.)

// В F# есть только три встроенных монады (seq, async, query), но можно определять собственные.
// Заметьте, что seq - наши ленивые последовательсности - на самом деле также монады!

// Синтаксис для монадических вычислений:
// builderExpr { body }
// Например,
let monad = seq { 1 .. 10 }

// Внутри монад можно использовать несколько дополнительных операторов:
// let!, do!, yield, yield!, return, return!
// Некоторые из них определены не для всех монад

// С yield и yield! мы уже знакомы:
// * yield возвращает наружу один элемент, но не завершает вычисление
// * yield! встраивает значения, полученные из монады-аргумента, в текущую
// Вспомним пример со случайным блужданием
let rec randomWalk2 x = seq {
    yield x
    yield! randomWalk2 (x + rand.NextDouble() - 0.5)
}

// Для знакомства с остальными методами рассмотрим монаду async. Для начала рассмотрим класс Async, который содержит
// методы для работы с асинхронными вычислениями

// return возвращает значение, как yield, но останавливает вычисление. Его больше нельзя продолжить
let getNum (num : int) = async { return num }  // int -> Async<int>

// let! связывает контсанту с вызовом другой монады. Если написать без восклицательного знака, то вычисление не будет
// запущено
let asyncPrinters = async {
    let! one = getNum 1
    return one
}

// return! запускает другое вычисление и возвращает его результат
let some = async {
    return! asyncPrinters
}

// do! будет дожидаться выполнения другого вычисления, которое ничего не возвращает
let print x = async { printfn "%A" x }  // -> Async<unit>
let waiter = async { do! print 1 }

// Для запуска асинхронных вычислений используется функция Async.RunSynchronously. Она запускает вычисление в отдельном
// потоке и дожидается его окончания. Если результат ждать не нужно, то есть Async.Start
waiter |> Async.RunSynchronously

// Для того, чтобы не дожидаться выполнения этого потока, используестся
// Async.Start
waiter |> Async.Start

